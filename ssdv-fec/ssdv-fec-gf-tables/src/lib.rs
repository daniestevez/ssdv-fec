//! # SSDV systematic erasure FEC: Galois field table generator procedural macros.
//!
//! This field contains procedural macros that are used to generate the tables
//! for the Galois field arithmetic in the `ssdv-fec` crate.
//!
//! The Galois field GF(2⁸) is realized as the quotient
//! GF(2)\[x\] / (x⁸ + x⁴ + x³ + x² + 1).
//! Its arithmetic is implemented using a table of the exponential
//! and a table of the logarithm, which are generated by this crate.
//!
//! An element a₇x⁷ + ⋯ + a₀ in GF(2⁸) is encoded as an element of `u8`, where
//! the leading coefficient a₇ is placed in the most-significant bit and the
//! independent term a₀ is placed in the least-significant bit.

#![warn(missing_docs)]

use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::ToTokens;

// Primitive polynomial p defining GF(2^8) as GF(2)[x] / (p)
// p = x^8 + x^4 + x^3 + x^2 + 1
const GF_POLY: u8 = 0b11101;

#[derive(Clone, Eq, PartialEq, Hash)]
struct Tables {
    exp_table: [u8; 256],
    log_table: [u8; 256],
}

impl Default for Tables {
    fn default() -> Tables {
        Tables {
            exp_table: [0; 256],
            log_table: [0; 256],
        }
    }
}

fn gf256_tables() -> Tables {
    let mut tables = Tables::default();
    let mut a = 1u8;
    for power in 0..255 {
        tables.exp_table[power] = a;
        tables.log_table[usize::from(a)] = u8::try_from(power).unwrap();
        a = if a & 0x80 != 0 {
            (a << 1) ^ GF_POLY
        } else {
            a << 1
        };
    }
    tables
}

macro_rules! impl_table {
    ($f:ident, $table:expr, $doc:expr) => {
        #[doc=$doc]
        #[proc_macro]
        pub fn $f(_: TokenStream) -> TokenStream {
            let table = $table;
            let mut elems = syn::punctuated::Punctuated::new();
            for a in table.iter() {
                let lit = syn::Lit::Int(syn::LitInt::new(&format!("{a}"), Span::call_site()));
                elems.push_value(syn::Expr::Lit(syn::ExprLit { attrs: vec![], lit }));
                elems.push_punct(syn::token::Comma {
                    spans: [Span::call_site()],
                });
            }
            let group = proc_macro2::Group::new(
                proc_macro2::Delimiter::Bracket,
                proc_macro2::TokenStream::new(),
            );
            let array = syn::Expr::Array(syn::ExprArray {
                attrs: vec![],
                bracket_token: syn::token::Bracket {
                    span: group.delim_span(),
                },
                elems,
            });
            array.into_token_stream().into()
        }
    };
}

impl_table!(
    gf256_exp_table,
    gf256_tables().exp_table,
    "Generates the exponential table for GF(2⁸).

This macro returns an array expresion of type `[u8; 256]` that corresponds to
the exponential table for GF(2⁸). The j-th entry of this table for j=0,...,254
contains the element xʲ encoded as a `u8`. The 255-th entry is not used in
practice and contains `0u8`."
);

impl_table!(
    gf256_log_table,
    gf256_tables().log_table,
    "Generates the logarithm table for GF(2⁸).

This macro returns an array expresion of type `[u8; 256]` that corresponds to
the logarithm table for GF(2⁸). The j-th entry of this table for j=1,...,255
contains the exponent k such that the element xᵏ encoded as a `u8` is equal to
j. The 0-th entry contains `0u8`, since the logarithm of 0 is undefined."
);
